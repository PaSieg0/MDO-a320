
%%% Preamble Requirements %%%
% \usepackage{geometry}
% \usepackage{amsfonts}
% \usepackage{amsmath}
% \usepackage{amssymb}
% \usepackage{tikz}

% Optional packages such as sfmath set through python interface
% \usepackage{sfmath}

% \usetikzlibrary{arrows,chains,positioning,scopes,shapes.geometric,shapes.misc,shadows}

%%% End Preamble Requirements %%%

\input{"C:/Users/Jaime/AppData/Roaming/Python/Python311/site-packages/pyxdsm/diagram_styles"}
\begin{tikzpicture}

\matrix[MatrixSetup]{
%Row 0
&
\node [DataIO] (output_opt) {$x_0$};&
\node [DataIO] (output_mda) {$W_{\text{wing}_{\text{ref}}} , W_{\text{fuel}_{\text{ref}}}$};&
\node [DataIO] (output_loads) {$\begin{array}{c}\Lambda_{\text{TE}_k}, b_k, \Gamma, \Theta_r, \tau_k, \tau_t \\ n_\text{max}, V_{\text{MO}_{\text{ref}}}, W_\text{A-W}\end{array}$};&
\node [DataIO] (output_struct) {$\begin{array}{c}\Lambda_{\text{TE}_k}, b_k, \Gamma, \Theta_r, \tau_k, \tau_t \\ E_\text{al}, \sigma_{y_\text{tens}}, \sigma_{y_\text{comp}}, \rho_\text{al} \\ (x/c)^{F,R}_{\text{spar}}, \rho_f, m_\text{eng}, y_\text{eng}\end{array}$};&
\node [DataIO] (output_aero) {$\Lambda_{\text{TE}_k}, b_k, \Gamma, \Theta_r, \tau_k, \tau_t, W_\text{A-W}$};&
\node [DataIO] (output_obj) {$\begin{array}{c}\bar{C_T}, g, W_\text{A-W} \\ f_\text{tank}, \rho_f, \Lambda_{\text{TE}_k}, b_k, g, (x/c)^{F,R}_{\text{spar}} \\ V_{\text{cr}_\text{ref}} , M_{\text{cr}_\text{ref}}\end{array}$};&
\node [DataIO] (output_ineq1) {$(W/S)_{\text{max}}, W_\text{A-W}, \Lambda_{\text{TE}_k}, b_k$};&
\node [DataIO] (output_ineq2) {$W_{f_{\text{ref}}}$};&
\node [DataIO] (output_ineq3) {$f_\text{tank}, \rho_f, \Lambda_{\text{TE}_k}, b_k, g, (x/c)^{F,R}_{\text{spar}}$};&
\\
%Row 1
\node [DataIO] (left_output_opt) {$x^*$};&
\node [Optimization] (opt) {$\begin{array}{c}0,7\rightarrow1 \\ \text{Optimizer}\end{array}$};&
&
\node [DataInter] (opt-loads) {$\begin{array}{c}2:b, c_r, c_t, \Lambda_{\text{LE}} \\ CST, t/c\end{array}$};&
\node [DataInter] (opt-struct) {$\begin{array}{c}3:b, c_r, c_t, \Lambda_{\text{LE}} \\ CST, t/c\end{array}$};&
\node [DataInter] (opt-aero) {$\begin{array}{c}4:h_\text{cr}, M_\text{cr} \\ b, c_r, c_t, \Lambda_{\text{LE}} \\ CST, t/c\end{array}$};&
\node [DataInter] (opt-obj) {$5:h_\text{cr}, M_\text{cr}$};&
\node [DataInter] (opt-ineq1) {$7:b, c_r, c_t, \Lambda_{\text{LE}}$};&
&
&
\\
%Row 2
&
&
\node [MDA] (mda) {$\begin{array}{c}1,6\rightarrow2 \\ \text{MDA Coordinator}\end{array}$};&
\node [DataInter] (mda-loads) {$2:\hat{W}_\text{wing}, \hat{W}_\text{fuel}$};&
\node [DataInter] (mda-struct) {$3:\hat{W}_\text{wing}, \hat{W}_\text{fuel}$};&
\node [DataInter] (mda-aero) {$4:\hat{W}_\text{fuel}$};&
\node [DataInter] (mda-obj) {$5:\hat{W}_\text{fuel}$};&
&
&
&
\\
%Row 3
&
&
&
\node [Function] (loads) {$2:\text{Loads}$};&
\node [DataInter] (loads-struct) {$3:L, M$};&
&
&
&
&
&
\\
%Row 4
\node [DataIO] (left_output_struct) {$W_\text{wing}^*$};&
&
\node [DataInter] (struct-mda) {$6:W_\text{wing}$};&
&
\node [Function] (struct) {$3:\text{Structures}$};&
\node [DataInter] (struct-aero) {$4:W_\text{wing}$};&
\node [DataInter] (struct-obj) {$5:W_\text{wing}$};&
\node [DataInter] (struct-ineq1) {$7:W_\text{wing}$};&
&
&
\\
%Row 5
&
&
&
&
&
\node [Function] (aero) {$4:\text{Aerodynamics}$};&
\node [DataInter] (aero-obj) {$5:L, D$};&
&
&
&
\\
%Row 6
\node [DataIO] (left_output_obj) {$R^*, W^*_\text{fuel}$};&
\node [DataInter] (obj-opt) {$7:R$};&
\node [DataInter] (obj-mda) {$6:W_\text{fuel}$};&
&
&
&
\node [Function] (obj) {$5:\text{Performance}$};&
\node [DataInter] (obj-ineq1) {$6:W_\text{fuel}$};&
\node [DataInter] (obj-ineq2) {$6:W_\text{fuel}$};&
\node [DataInter] (obj-ineq3) {$6:W_\text{fuel}$};&
\\
%Row 7
\node [DataIO] (left_output_ineq1) {$g^*_\text{ineq1}$};&
\node [DataInter] (ineq1-opt) {$7:g_\text{ineq1}$};&
&
&
&
&
&
\node [ImplicitFunction] (ineq1) {$\begin{array}{c}7:\text{Inequality 1} \\ W/S \le (W/S)_{\text{max}}\end{array}$};&
&
&
\\
%Row 8
\node [DataIO] (left_output_ineq2) {$g^*_\text{ineq2}$};&
\node [DataInter] (ineq2-opt) {$7:g_\text{ineq2}$};&
&
&
&
&
&
&
\node [ImplicitFunction] (ineq2) {$\begin{array}{c}7:\text{Inequality 2} \\ W_\text{fuel} \le W_{f_{\text{ref}}}\end{array}$};&
&
\\
%Row 9
\node [DataIO] (left_output_ineq3) {$g^*_\text{ineq3}$};&
\node [DataInter] (ineq3-opt) {$7:g_\text{ineq3}$};&
&
&
&
&
&
&
&
\node [ImplicitFunction] (ineq3) {$\begin{array}{c}7:\text{Inequality 3} \\ W_\text{fuel} \le V_{\text{tank}} f_\text{tank} \rho_{\text{f}} g\end{array}$};&
\\
%Row 10
&
&
&
&
&
&
&
&
&
&
\\
};

% XDSM process chains
{ [start chain=process]
 \begin{pgfonlayer}{process} 
\chainin (opt);
\chainin (mda) [join=by ProcessHVA];
\chainin (loads) [join=by ProcessHVA];
\chainin (struct) [join=by ProcessHVA];
\chainin (aero) [join=by ProcessHVA];
\chainin (obj) [join=by ProcessHVA];
\chainin (mda) [join=by ProcessHVA];
\end{pgfonlayer}
}{ [start chain=process]
 \begin{pgfonlayer}{process} 
\chainin (obj);
\chainin (ineq1) [join=by ProcessHVA];
\chainin (opt) [join=by ProcessHVA];
\end{pgfonlayer}
}{ [start chain=process]
 \begin{pgfonlayer}{process} 
\chainin (obj);
\chainin (ineq2) [join=by ProcessHVA];
\chainin (opt) [join=by ProcessHVA];
\end{pgfonlayer}
}{ [start chain=process]
 \begin{pgfonlayer}{process} 
\chainin (obj);
\chainin (ineq3) [join=by ProcessHVA];
\chainin (opt) [join=by ProcessHVA];
\end{pgfonlayer}
}

\begin{pgfonlayer}{data}
\path
% Horizontal edges
(opt) edge [DataLine] (opt-loads)
(opt) edge [DataLine] (opt-struct)
(opt) edge [DataLine] (opt-aero)
(opt) edge [DataLine] (opt-obj)
(opt) edge [DataLine] (opt-ineq1)
(mda) edge [DataLine] (mda-loads)
(mda) edge [DataLine] (mda-struct)
(mda) edge [DataLine] (mda-aero)
(mda) edge [DataLine] (mda-obj)
(loads) edge [DataLine] (loads-struct)
(struct) edge [DataLine] (struct-aero)
(struct) edge [DataLine] (struct-obj)
(struct) edge [DataLine] (struct-ineq1)
(aero) edge [DataLine] (aero-obj)
(obj) edge [DataLine] (obj-ineq1)
(obj) edge [DataLine] (obj-ineq2)
(obj) edge [DataLine] (obj-ineq3)
(struct) edge [DataLine] (struct-mda)
(obj) edge [DataLine] (obj-mda)
(obj) edge [DataLine] (obj-opt)
(ineq1) edge [DataLine] (ineq1-opt)
(ineq2) edge [DataLine] (ineq2-opt)
(ineq3) edge [DataLine] (ineq3-opt)
(opt) edge [DataLine] (left_output_opt)
(struct) edge [DataLine] (left_output_struct)
(obj) edge [DataLine] (left_output_obj)
(ineq1) edge [DataLine] (left_output_ineq1)
(ineq2) edge [DataLine] (left_output_ineq2)
(ineq3) edge [DataLine] (left_output_ineq3)
% Vertical edges
(opt-loads) edge [DataLine] (loads)
(opt-struct) edge [DataLine] (struct)
(opt-aero) edge [DataLine] (aero)
(opt-obj) edge [DataLine] (obj)
(opt-ineq1) edge [DataLine] (ineq1)
(mda-loads) edge [DataLine] (loads)
(mda-struct) edge [DataLine] (struct)
(mda-aero) edge [DataLine] (aero)
(mda-obj) edge [DataLine] (obj)
(loads-struct) edge [DataLine] (struct)
(struct-aero) edge [DataLine] (aero)
(struct-obj) edge [DataLine] (obj)
(struct-ineq1) edge [DataLine] (ineq1)
(aero-obj) edge [DataLine] (obj)
(obj-ineq1) edge [DataLine] (ineq1)
(obj-ineq2) edge [DataLine] (ineq2)
(obj-ineq3) edge [DataLine] (ineq3)
(struct-mda) edge [DataLine] (mda)
(obj-mda) edge [DataLine] (mda)
(obj-opt) edge [DataLine] (opt)
(ineq1-opt) edge [DataLine] (opt)
(ineq2-opt) edge [DataLine] (opt)
(ineq3-opt) edge [DataLine] (opt)
(opt) edge [DataLine] (output_opt)
(mda) edge [DataLine] (output_mda)
(loads) edge [DataLine] (output_loads)
(struct) edge [DataLine] (output_struct)
(aero) edge [DataLine] (output_aero)
(obj) edge [DataLine] (output_obj)
(ineq1) edge [DataLine] (output_ineq1)
(ineq2) edge [DataLine] (output_ineq2)
(ineq3) edge [DataLine] (output_ineq3);
\end{pgfonlayer}

\end{tikzpicture}
